/*voice*//*when who why modified*/#include <telephony/ril.h>#include <stdio.h>#include <assert.h>#include <string.h>#include <errno.h>#include <unistd.h>#include <sys/types.h>#include <sys/stat.h>#include <fcntl.h>#include <pthread.h>#include <alloca.h>#include "atchannel.h"#include "at_tok.h"#include "misc.h"#include <getopt.h>#include <sys/socket.h>#include <cutils/sockets.h>#include <cutils/properties.h>#include <termios.h>#include "ril_common.h"#include "voice.h"#include "ril.h"static const struct timeval TIMEVAL_CALLSTATEPOLL = {0,500000};/*called by callFromCLCCLine()*/static int clccStateToRILState(int state, RIL_CallState *p_state){    switch(state)    {    case 0:        *p_state = RIL_CALL_ACTIVE;        return 0;    case 1:        *p_state = RIL_CALL_HOLDING;        return 0;    case 2:        *p_state = RIL_CALL_DIALING;        return 0;    case 3:        *p_state = RIL_CALL_ALERTING;        return 0;    case 4:        *p_state = RIL_CALL_INCOMING;        return 0;    case 5:        *p_state = RIL_CALL_WAITING;        return 0;    default:        return -1;    }}/** * Note: directly modified line and has *p_call point directly into * modified line * called by requestGetCurrentCalls() */static int callFromCLCCLine(char *line, RIL_Call *p_call){    //+CLCC: 1,0,2,0,0,\"+18005551212\",145    //     index,isMT,state,mode,isMpty(,number,TOA)?    int err;    int state;    int mode;    err = at_tok_start(&line);    if (err < 0) goto error;    err = at_tok_nextint(&line, &(p_call->index));    if (err < 0) goto error;    err = at_tok_nextbool(&line, &(p_call->isMT));    if (err < 0) goto error;    err = at_tok_nextint(&line, &state);    if (err < 0) goto error;    err = clccStateToRILState(state, &(p_call->state));    if (err < 0) goto error;    err = at_tok_nextint(&line, &mode);    if (err < 0) goto error;    p_call->isVoice = (mode == 0);    err = at_tok_nextbool(&line, &(p_call->isMpty));    if (err < 0) goto error;    if (at_tok_hasmore(&line))    {        err = at_tok_nextstr(&line, &(p_call->number));        /* tolerate null here */        if (err < 0) return 0;        // Some lame implementations return strings        // like "NOT AVAILABLE" in the CLCC line        if (p_call->number != NULL                && 0 == strspn(p_call->number, "+0123456789")           )        {            p_call->number = NULL;        }        err = at_tok_nextint(&line, &p_call->toa);        if (err < 0) goto error;    }    return 0;error:    ALOGD("invalid CLCC line\n");    return -1;}/*called by requestGetCurrentCalls()*/static void sendCallStateChanged(void *param){    RIL_onUnsolicitedResponse (        RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED,        NULL, 0);}void requestGetCurrentCalls(void *data, size_t datalen, RIL_Token t){    int err;    ATResponse *p_response;    ATLine *p_cur;    int countCalls;    int countValidCalls;    RIL_Call *p_calls;    RIL_Call **pp_calls;    int i;    int needRepoll = 0;#ifdef WORKAROUND_ERRONEOUS_ANSWER    int prevIncomingOrWaitingLine;    prevIncomingOrWaitingLine = s_incomingOrWaitingLine;    s_incomingOrWaitingLine = -1;#endif /*WORKAROUND_ERRONEOUS_ANSWER*/    err = at_send_command_multiline ("AT+CLCC", "+CLCC:", &p_response);    if (err != 0 || p_response->success == 0)    {        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);        return;    }    /* count the calls */    for (countCalls = 0, p_cur = p_response->p_intermediates                                 ; p_cur != NULL            ; p_cur = p_cur->p_next        )    {        countCalls++;    }    /* yes, there's an array of pointers and then an array of structures */    pp_calls = (RIL_Call **)alloca(countCalls * sizeof(RIL_Call *));    p_calls = (RIL_Call *)alloca(countCalls * sizeof(RIL_Call));    memset (p_calls, 0, countCalls * sizeof(RIL_Call));    /* init the pointer array */    for(i = 0; i < countCalls ; i++)    {        pp_calls[i] = &(p_calls[i]);    }    for (countValidCalls = 0, p_cur = p_response->p_intermediates                                      ; p_cur != NULL            ; p_cur = p_cur->p_next        )    {        err = callFromCLCCLine(p_cur->line, p_calls + countValidCalls);        if (err != 0)        {            continue;        }#ifdef WORKAROUND_ERRONEOUS_ANSWER        if (p_calls[countValidCalls].state == RIL_CALL_INCOMING                || p_calls[countValidCalls].state == RIL_CALL_WAITING           )        {            s_incomingOrWaitingLine = p_calls[countValidCalls].index;        }#endif /*WORKAROUND_ERRONEOUS_ANSWER*/        if (p_calls[countValidCalls].state != RIL_CALL_ACTIVE                && p_calls[countValidCalls].state != RIL_CALL_HOLDING           )        {            needRepoll = 1;        }        countValidCalls++;    }    //}//added by zte-yuyang#ifdef WORKAROUND_ERRONEOUS_ANSWER    // Basically:    // A call was incoming or waiting    // Now it's marked as active    // But we never answered it    //    // This is probably a bug, and the call will probably    // disappear from the call list in the next poll    if (prevIncomingOrWaitingLine >= 0            && s_incomingOrWaitingLine < 0            && s_expectAnswer == 0       )    {        for (i = 0; i < countValidCalls ; i++)        {            if (p_calls[i].index == prevIncomingOrWaitingLine                    && p_calls[i].state == RIL_CALL_ACTIVE                    && s_repollCallsCount < REPOLL_CALLS_COUNT_MAX               )            {                ALOGD(                    "Hit WORKAROUND_ERRONOUS_ANSWER case."                    " Repoll count: %d\n", s_repollCallsCount);                s_repollCallsCount++;                goto error;            }        }    }    s_expectAnswer = 0;    s_repollCallsCount = 0;#endif /*WORKAROUND_ERRONEOUS_ANSWER*/    RIL_onRequestComplete(t, RIL_E_SUCCESS, pp_calls,                          countValidCalls * sizeof (RIL_Call *));    at_response_free(p_response);#ifdef POLL_CALL_STATE    if (countValidCalls)    // We don't seem to get a "NO CARRIER" message from    {        // smd, so we're forced to poll until the call ends.#else    if (needRepoll)    {#endif        RIL_requestTimedCallback (sendCallStateChanged, NULL, &TIMEVAL_CALLSTATEPOLL);    }    return;error:    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);    at_response_free(p_response);}void requestDial(void *data, size_t datalen, RIL_Token t){    RIL_Dial *p_dial;    char *cmd;    const char *clir;    int ret;    p_dial = (RIL_Dial *)data;    switch (p_dial->clir)    {    case 1:        clir = "I";        break;  /*invocation*/    case 2:        clir = "i";        break;  /*suppression*/    default:    case 0:        clir = "";        break;   /*subscription default*/    }    ALOGD("It's ZTE dial");    asprintf(&cmd, "ATD%s%s;", p_dial->address, clir);    ret = at_send_command(cmd, NULL);    free(cmd);    /* success or failure is ignored by the upper layer here.       it will call GET_CURRENT_CALLS and determine success that way */    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void  requestGetMute(void *data, size_t datalen, RIL_Token t){    int response = 0;    RIL_onRequestComplete(t, RIL_E_SUCCESS, &response,sizeof(response));}void requestDTMFStart(void *data, size_t datalen, RIL_Token t){    char c = ((char *)data)[0];    char *cmd;    at_send_command("AT+CMUT=1", NULL);    asprintf(&cmd, "AT+VTS=%c", (int)c);    at_send_command(cmd, NULL);    if(c=='*')        at_send_command("AT+WFSH", NULL);    free(cmd);    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestDTMFStop(void *data, size_t datalen, RIL_Token t){    at_send_command("AT+CMUT=0", NULL);    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestDTMF(void *data, size_t datalen, RIL_Token t){    char c = ((char *)data)[0];    char *cmd;    asprintf(&cmd, "AT+VTS=%c", (int)c);    at_send_command(cmd, NULL);    free(cmd);    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestSeparateConnection(void *data, size_t datalen, RIL_Token t){    char  cmd[12];    int   party = ((int*)data)[0];    // Make sure that party is in a valid range.    // (Note: The Telephony middle layer imposes a range of 1 to 7.    // It's sufficient for us to just make sure it's single digit.)    if (party > 0 && party < 10)    {        sprintf(cmd, "AT+CHLD=2%d", party);        at_send_command(cmd, NULL);        RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);    }    else    {        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);    }}void requestUDUB(void *data, size_t datalen, RIL_Token t){    /* user determined user busy */    /* sometimes used: ATH */    at_send_command("ATH", NULL);    /* success or failure is ignored by the upper layer here.       it will call GET_CURRENT_CALLS and determine success that way */    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestConference(void *data, size_t datalen, RIL_Token t){    // 3GPP 22.030 6.5.5    // "Adds a held call to the conversation"    at_send_command("AT+CHLD=3", NULL);    /* success or failure is ignored by the upper layer here.         it will call GET_CURRENT_CALLS and determine success that way */    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestAnswer(void *data, size_t datalen, RIL_Token t){    at_send_command("ATA", NULL);#ifdef WORKAROUND_ERRONEOUS_ANSWER    s_expectAnswer = 1;#endif  /* WORKAROUND_ERRONEOUS_ANSWER */    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestSwitchWaitingOrHoldingAndActive(void *data, size_t datalen, RIL_Token t){    // 3GPP 22.030 6.5.5    // "Places all active calls (if any exist) on hold and accepts    //  the other (held or waiting) call."    at_send_command("AT+CHLD=2", NULL);#ifdef WORKAROUND_ERRONEOUS_ANSWER    s_expectAnswer = 1;#endif /* WORKAROUND_ERRONEOUS_ANSWER */    /* success or failure is ignored by the upper layer here.       it will call GET_CURRENT_CALLS and determine success that way */    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestHangupForegroundResumeBackground(void *data, size_t datalen, RIL_Token t){    // 3GPP 22.030 6.5.5    // "Releases all active calls (if any exist) and accepts    //  the other (held or waiting) call."    //at_send_command("AT+CHLD=1", NULL);    at_send_command("AT+CHUP", NULL);    /* success or failure is ignored by the upper layer here.       it will call GET_CURRENT_CALLS and determine success that way */    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestHangupWaitingOrBackground(void *data, size_t datalen, RIL_Token t){    // 3GPP 22.030 6.5.5    // "Releases all held calls or sets User Determined User Busy    //  (UDUB) for a waiting call."    //at_send_command("AT+CHLD=0", NULL);    at_send_command("AT+CHUP", NULL);    /* success or failure is ignored by the upper layer here.       it will call GET_CURRENT_CALLS and determine success that way */    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}void requestHangup(void *data, size_t datalen, RIL_Token t){
    int *p_line;

    int ret;
    char *cmd;

   p_line = (int *)data;

 // 3GPP 22.030 6.5.5
    // "Releases a specific active call X"
   asprintf(&cmd, "AT+CHLD=1%d", p_line[0]);

//#ifdef ZTE_MODIFY_BY_JOEY.MING
   //ret = at_send_command(cmd, NULL);

  ret = at_send_command("AT+CHUP", NULL);//modified by zte-zhaoming
//#endif
   free(cmd);

   /* success or failure is ignored by the upper layer here.
     it will call GET_CURRENT_CALLS and determine success that way */
    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);}
/* added by zte-yuyang begin */void  requestGetClir(void *data, size_t datalen, RIL_Token t){ /** Gets current CLIR status * "data" is NULL * "response" is int * * ((int *)data)[0] is "n" parameter from TS 27.007 7.7 * ((int *)data)[1] is "m" parameter from TS 27.007 7.7 */ int err; int *response[2]; ATResponse *p_response; char* line; err = at_send_command_singleline("AT+CLIR?","+CLIR:",&p_response);    if (err != 0 || p_response->success == 0) 		goto error;    line = p_response->p_intermediates->line;    err = at_tok_start(&line);    if (err < 0) goto error;	    err = at_tok_nextint(&line, &response[0]);    if (err < 0) goto error;    err = at_tok_nextint(&line, &response[1]);    if (err < 0) goto error;    RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));	at_response_free(p_response);	return;	error:     RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);	 at_response_free(p_response);	 return;	}void  requestSetClir(void *data, size_t datalen, RIL_Token t){/** * "data" is int * * ((int *)data)[0] is "n" parameter from TS 27.007 7.7 * * "response" is NULL */int err;char *cmd;asprintf(&cmd, "AT+CLIR=%d", ((int *)data)[0]);
err = at_send_command(cmd,NULL);if (err < 0)	goto error;free(cmd);RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);return;error:RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);}void requestQueryCallWaiting(void *data, size_t datalen, RIL_Token t){ /** * "data" is const int * * ((const int *)data)[0] is the TS 27.007 service class to query. * "response" is a const int * * ((const int *)response)[0] is 0 for "disabled" and 1 for "enabled" * * If ((const int *)response)[0] is = 1, then ((const int *)response)[1] * must follow, with the TS 27.007 service class bit vector of services * for which call waiting is enabled. * * For example, if ((const int *)response)[0]  is 1 and * ((const int *)response)[1] is 3, then call waiting is enabled for data * and voice and disabled for everything else */    int err;    int i;    int skip;    ATLine *p_cur;    int *response[2];	char*cmd;#define  SERVICE_NUMBER 5
//const int SERVICE_NUMBER = 5;	int response_enable[SERVICE_NUMBER] = {0};//0:disable;1:enable	int response_class[SERVICE_NUMBER] = {0};//service class    ATResponse *p_response = NULL;	/* generally,the service_class is 2,it means data*/	int service_class = ((const int *)data)[0];    asprintf(&cmd,"AT+CCWA=1,%d",service_class);	memset(response, 0, sizeof(response));	 err = at_send_command_multiline(cmd,"+CCWA:", &p_response); free(cmd);    /* we expect 3 lines here:     * +CCWA: 1,1     * +CCWA: 1,2     * +CCWA: 1,4     */    if (err != 0) goto error;    for (i = 0, p_cur = p_response->p_intermediates                        ; p_cur != NULL            ; p_cur = p_cur->p_next, i++        )    {        char *line = p_cur->line;        err = at_tok_start(&line);        if (err < 0) goto error;        err = at_tok_nextint(&line, &response_enable[i]);        if (err < 0) goto error;		        err = at_tok_nextint(&line, &response_class[i]);        if (err < 0) goto error;    }for(i = 0;i<SERVICE_NUMBER;i++){    if(response_enable[i] == 1 )    	{    	    *(response[0]) = 1;			*(response[1]) += response_class[i];    	}    }    RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));    at_response_free(p_response);    return;error:    ALOGD("******** requestQueryCallWaiting is failed ********");    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);    at_response_free(p_response);}void requestSetCallWaiting(void *data, size_t datalen, RIL_Token t){ /** * "data" is const int * * ((const int *)data)[0] is 0 for "disabled" and 1 for "enabled" * ((const int *)data)[1] is the TS 27.007 service class bit vector of *                           services to modify * "response" is NULL */ int err = 0; char*cmd = NULL; int enable = ((const int *)data)[0]; int service_class = ((const int *)data)[1];  asprintf(&cmd,"AT+CCWA=%d,%d",enable,service_class); err = at_send_command(cmd,NULL); if (err < 0) 	goto error; free(cmd); RIL_onRequestComplete(t,RIL_E_SUCCESS,NULL,0); error: 	RIL_onRequestComplete(t,RIL_E_GENERIC_FAILURE,NULL,0);}/* added by zte-yuyang end */